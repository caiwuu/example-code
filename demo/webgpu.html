<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGPU 示例</title>
  </head>
  <body>
    <canvas id="webgpuCanvas" width="800" height="600"></canvas>
    <script>
      async function initWebGPU() {
        // 检查是否支持 WebGPU
        if (!navigator.gpu) {
          console.error('WebGPU 不支持此浏览器')
          return
        }

        // 获取 GPU 设备
        const adapter = await navigator.gpu.requestAdapter()
        const device = await adapter.requestDevice()

        // 创建渲染上下文
        const canvas = document.getElementById('webgpuCanvas')
        const context = canvas.getContext('webgpu')

        // 设置视口
        const format = 'bgra8unorm'
        context.configure({
          device: device,
          format: format,
        })

        // 创建顶点缓冲区
        const vertexBuffer = device.createBuffer({
          size: 4 * 3 * 2, // 3 个顶点，每个顶点 2 个浮点数
          usage: GPUBufferUsage.VERTEX,
          mappedAtCreation: true,
        })

        const vertexData = new Float32Array([
          0.0,
          0.5, // 顶点 1
          -0.5,
          -0.5, // 顶点 2
          0.5,
          -0.5, // 顶点 3
        ])

        new Float32Array(vertexBuffer.getMappedRange()).set(vertexData)
        vertexBuffer.unmap()

        // 创建渲染管线
        const pipeline = device.createRenderPipeline({
          vertex: {
            module: device.createShaderModule({
              code: `
                            @stage(vertex)
                            fn vs_main(@location(0) position: vec2<f32>) -> @builtin(position) vec4<f32> {
                                return vec4<f32>(position, 0.0, 1.0);
                            }
                        `,
            }),
            entryPoint: 'vs_main',
          },
          fragment: {
            module: device.createShaderModule({
              code: `
                            @stage(fragment)
                            fn fs_main() -> @location(0) vec4<f32> {
                                return vec4<f32>(1.0, 0.0, 0.0, 1.0); // 红色
                            }
                        `,
            }),
            entryPoint: 'fs_main',
            targets: [
              {
                format: format,
              },
            ],
          },
          primitive: {
            topology: 'triangle-list',
          },
        })

        // 渲染循环
        function frame() {
          const commandEncoder = device.createCommandEncoder()
          const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [
              {
                view: context.getCurrentTexture().createView(),
                loadValue: [0, 0, 0, 1], // 背景色为黑色
                storeOp: 'store',
              },
            ],
          })

          renderPass.setPipeline(pipeline)
          renderPass.setVertexBuffer(0, vertexBuffer)
          renderPass.draw(3, 1, 0, 0) // 绘制 3 个顶点
          renderPass.endPass()

          device.queue.submit([commandEncoder.finish()])
          requestAnimationFrame(frame)
        }

        frame()
      }

      initWebGPU()
    </script>
  </body>
</html>
